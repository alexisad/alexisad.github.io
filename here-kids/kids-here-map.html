<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>First Atlas for Kids</title>
    <script src="https://js.api.here.com/v3/3.2/mapsjs-core.js"></script>
    <script src="https://js.api.here.com/v3/3.2/mapsjs-service.js"></script>
    <script src="https://js.api.here.com/v3/3.2/mapsjs-ui.js"></script>
    <script src="https://js.api.here.com/v3/3.2/mapsjs-mapevents.js"></script>
    <script type="text/javascript" src="https://js.api.here.com/v3/3.2/mapsjs-clustering.js"></script>
    <link rel="stylesheet" type="text/css" href="https://js.api.here.com/v3/3.2/mapsjs-ui.css" />
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@700;900&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Nunito', Arial, sans-serif;
            background: #f0f0f0;
        }
        .page {
            width: 190mm;
            height: 270mm;
            margin: 10mm auto;
            background: white;
            border: 1px solid #ccc;
            position: relative;
            display: flex;
            flex-direction: column;
        }

        /* Page 1: Form */
        .page-form {
            padding: 40mm 0;
            align-items: center;
            justify-content: space-between;
        }
        .form-group {
            margin-bottom: 50mm;
            text-align: center;
            width: 100%;
        }
        .print-button {
            padding: 4mm 8mm;
            font-size: 16pt;
            font-weight: 700;
            font-family: 'Nunito', Arial, sans-serif;
            background: #0066CC;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            margin-bottom: 10mm;
        }
        .print-button:hover {
            background: #0052A3;
        }
        .form-label {
            font-size: 32pt;
            font-weight: 900;
            color: #333;
            text-shadow: 2px 2px 0 #ccc;
            display: block;
            margin-bottom: 15mm;
        }
        .form-input {
            width: 150mm;
            border: none;
            border-bottom: 3px solid #333;
            font-size: 24pt;
            font-family: 'Nunito', Arial, sans-serif;
            text-align: center;
            outline: none;
            padding: 5mm 0;
            display: block;
            margin: 0 auto;
        }
        .form-input-address {
            width: 150mm;
            min-height: 20mm;
            border: none;
            border-bottom: 3px solid #333;
            font-size: 18pt;
            font-family: 'Nunito', Arial, sans-serif;
            text-align: center;
            outline: none;
            padding: 3mm 5mm;
            display: block;
            margin: 0 auto;
            resize: none;
            overflow: hidden;
            line-height: 1.4;
        }
        .autocomplete-wrapper {
            position: relative;
            display: block;
            width: 150mm;
            margin: 0 auto;
        }
        .autocomplete-list {
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            width: 140mm;
            max-height: 60mm;
            overflow-y: auto;
            background: white;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
            z-index: 100;
            display: none;
        }
        .autocomplete-list.show {
            display: block;
        }
        .autocomplete-item {
            padding: 3mm 5mm;
            font-size: 14pt;
            cursor: pointer;
            text-align: left;
            border-bottom: 1px solid #eee;
        }
        .autocomplete-item:last-child {
            border-bottom: none;
        }
        .autocomplete-item:hover {
            background: #f0f7ff;
        }

        /* Page 2: Title */
        .page-title {
            justify-content: flex-start;
            align-items: center;
            padding-top: 30mm;
        }
        .title-main {
            font-size: 48pt;
            font-weight: 900;
            color: #333;
            text-shadow: 3px 3px 0 #bbb;
            text-align: center;
        }
        .title-of {
            font-size: 36pt;
            font-weight: 700;
            color: #333;
            text-shadow: 2px 2px 0 #ccc;
            margin: 20mm 0;
            text-align: center;
        }
        .title-name {
            font-size: 54pt;
            font-weight: 900;
            color: #3db4b4;
            text-shadow: 3px 3px 0 #2a8a8a;
            text-align: center;
        }
        .title-footer {
            position: absolute;
            bottom: 20mm;
            right: 25mm;
            font-size: 24pt;
            font-weight: 700;
        }
        .title-footer .for {
            color: #333;
        }
        .title-footer .k {
            color: #8bc34a;
        }
        .title-footer .i {
            color: #ff9800;
        }
        .title-footer .d {
            color: #e91e63;
        }
        .title-footer .s {
            color: #9c27b0;
        }
        .title-here-logo {
            position: absolute;
            left: 25mm;
            bottom: 20mm;
        }

        /* Page 3: Map */
        .page-map {
            padding: 0;
            padding-left: 20mm;
            width: 210mm;
            margin-left: 0;
            display: flex;
            flex-direction: column;
            position: relative;
        }
        .map-header {
            padding: 6mm 0 6mm 0;
            text-align: center;
            background: white;
        }
        .map-header-line1 {
            font-size: 18pt;
            font-weight: 700;
            color: #333;
            margin-bottom: 3mm;
        }
        .map-header-line2 {
            font-size: 16pt;
            font-weight: 700;
            color: #333;
        }
        .map-header-city {
            color: #e91e63;
        }
        .map-header-address {
            color: #e91e63;
        }
        .map-page-number {
            position: absolute;
            bottom: 2mm;
            left: 0;
            right: 0;
            text-align: center;
            font-size: 14pt;
            font-weight: 700;
            color: #666;
            padding: 3mm 0;
        }
        #map, #cityMap, #countryMap, #continentMap {
            width: 100%;
            flex: 1;
        }

        /* Page 7: Exploration Questions */
        .page-explore {
            width: 100%;
            max-width: 900px;
            height: auto;
            margin: 20px auto;
            padding: 40px 60px;
            box-sizing: border-box;
        }
        .explore-title {
            font-size: 36px;
            font-weight: 900;
            color: #333;
            text-align: center;
            margin-bottom: 30px;
            text-shadow: 2px 2px 0 #ccc;
        }
        .explore-subtitle {
            font-size: 16px;
            font-weight: 700;
            color: #555;
            margin-bottom: 25px;
            line-height: 1.6;
        }
        .explore-section {
            margin-bottom: 30px;
        }
        .explore-section-title {
            font-size: 24px;
            font-weight: 900;
            color: #e91e63;
            margin-bottom: 12px;
        }
        .explore-list {
            padding-left: 30px;
            margin: 0;
        }
        .explore-list li {
            font-size: 16px;
            font-weight: 700;
            color: #333;
            margin-bottom: 8px;
            padding-left: 8px;
        }

        /* Page 8: Create Your Own Map */
        .page-create {
            width: 100%;
            max-width: 1800px;
            height: auto;
            margin: 20px auto;
            padding: 40px 60px;
            box-sizing: border-box;
        }
        .create-content {
            display: flex;
            gap: 20px;
        }
        .icons-section {
            flex: 0 0 300px;
        }
        .map-section {
            flex: 1;
            min-height: 700px;
            border: 2px solid #333;
            position: relative;
            background: #f9f9f9;
        }
        #interactiveMap {
            width: 100%;
            height: 100%;
        }
        .create-title {
            font-size: 36px;
            font-weight: 900;
            color: #333;
            margin-bottom: 20px;
            text-shadow: 2px 2px 0 #ccc;
        }
        .create-subtitle {
            font-size: 16px;
            font-weight: 700;
            color: #555;
            margin-bottom: 30px;
            line-height: 1.6;
            font-style: italic;
        }
        .icons-grid {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .icon-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .icon-item {
            width: 45px;
            height: 45px;
            font-size: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            cursor: pointer;
            transition: opacity 0.3s;
        }
        .icon-item:hover {
            opacity: 0.7;
        }
        .icon-item.used {
            opacity: 0.2;
            pointer-events: none;
        }
        .icon-label {
            font-size: 18px;
            font-weight: 700;
            color: #333;
            min-width: 180px;
        }

        @media screen {
            .page-title,
            .page-map {
                position: absolute;
                left: -9999px;
                top: 0;
            }
            .map-page-number {
                display: none;
            }
            .pdf-page-print-only,
            .pdf-page-print-only .map-page-number {
                display: none !important;
            }
        }

        @media print {
            @page {
                size: A4 portrait;
                margin: 10mm;
            }
            body {
                background: white;
            }
            .page.page-form,
            .page.page-explore,
            .page.page-create {
                display: none !important;
            }
            .page-title {
                position: static !important;
                left: auto !important;
            }
            .page-map {
                position: relative !important;
                left: auto !important;
            }
            .page {
                margin: 0;
                border: none;
                page-break-after: always;
                break-after: page;
                display: flex !important;
            }
            .page:last-child {
                page-break-after: avoid;
            }
            #map, #cityMap, #countryMap, #continentMap {
                page-break-inside: avoid;
                break-inside: avoid;
            }
            .pdf-page-print-only {
                display: flex !important;
                position: relative !important;
                left: auto !important;
                padding: 0 !important;
                align-items: center;
                justify-content: center;
            }
            .pdf-page-image {
                width: 115%;
                height: auto;
                max-width: 218mm;
                max-height: 310mm;
                object-fit: contain;
            }
        }
    </style>
</head>
<body>
    <!-- Page 1: Form -->
    <div class="page page-form">
        <div class="form-group">
            <label class="form-label">Address:</label>
            <div class="autocomplete-wrapper">
                <textarea class="form-input-address" id="addressInput" rows="2" placeholder="" autocomplete="off"></textarea>
                <div class="autocomplete-list" id="autocompleteList"></div>
            </div>
        </div>
        <div class="form-group">
            <label class="form-label">Name:</label>
            <input type="text" class="form-input" id="nameInput" placeholder="">
        </div>
        <button class="print-button" onclick="window.print()">Print</button>
    </div>

    <!-- Page 2: Title -->
    <div class="page page-title">
        <div class="title-main">First Atlas</div>
        <div class="title-of">of</div>
        <div class="title-name" id="titleName"></div>
        <div class="title-here-logo">
            <svg width="142" height="142" viewBox="0 0 142 142" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M53 99.5437L42.066 110.478L31.0847 99.5437H53Z" fill="#00A69A"/>
                <path d="M68.9887 74.599C66.7167 71.901 66.8113 70.4337 68.2313 69.0137C69.9353 67.3097 71.6867 68.0197 73.6747 69.913L68.9887 74.599ZM92.4187 44.8263C94.1227 43.1223 95.874 43.8323 97.862 45.7257L93.176 50.4117C90.904 47.7137 90.9987 46.2463 92.4187 44.8263ZM106.571 49.607C104.441 52.7783 100.749 57.9377 96.868 54.0563L106.713 44.211C105.814 43.2643 105.151 42.4597 104.631 41.9863C99.3293 36.685 93.3653 36.5903 88.6793 41.2763C85.5553 44.4003 84.7507 47.9503 85.65 51.3583L82.5733 47.8557C81.674 48.329 77.8873 51.6897 80.7273 56.707L77.2247 53.7723L72.5387 58.4583L78.834 64.7537C73.9587 60.8723 68.7047 61.251 64.492 65.4637C59.9953 69.9603 60.2793 75.451 63.6873 79.9477L63.0247 79.285C58.5753 74.8357 53.7 76.3977 51.286 78.8117C49.44 80.6577 48.304 83.2137 48.7773 85.0123L39.074 75.309L33.9147 80.4683L52.99 99.5437H63.214L56.3507 92.6803C52.7533 88.9883 52.6587 87.0477 54.41 85.2963C56.114 83.5923 58.0547 84.681 61.5573 88.1363L68.3733 94.9523L73.4853 89.8403L67.048 83.403C71.6867 86.9057 77.272 87.095 82.242 82.1723C82.2893 82.125 82.2893 82.125 82.3367 82.0777C85.366 79.285 86.2653 76.5397 86.2653 76.5397L82.384 73.9363C80.254 77.1077 76.562 82.267 72.6807 78.3857L82.526 68.5403L88.6793 74.6937L94.028 69.345L86.36 61.4877C82.7627 57.8903 84.8927 54.5297 86.4073 53.2517C87.1173 54.719 88.1113 56.139 89.4367 57.4643C94.4067 62.4343 100.844 63.4283 106.477 57.843C106.524 57.7957 106.524 57.7957 106.571 57.7483C109.601 54.9557 110.5 52.2103 110.5 52.2103L106.571 49.607Z" fill="#153947"/>
            </svg>
        </div>
        <div class="title-footer">
            <span class="for">for </span><span class="k">k</span><span class="i">i</span><span class="d">d</span><span class="s">s</span>
        </div>
    </div>

    <!-- Page 3: Earth -->
    <div class="page page-map" style="padding-left: 20mm;">
        <div class="map-header">
            <div class="map-header-line1">You live on the planet <span class="map-header-city">Earth</span></div>
        </div>
        <div style="flex: 1; display: flex; align-items: center; justify-content: center;">
            <img src="earth.png" alt="Earth" style="width: 100%; height: 100%; object-fit: contain;">
        </div>
        <div class="map-page-number">1</div>
    </div>

    <!-- Page 4: Continent Map -->
    <div class="page page-map">
        <div class="map-header">
            <div class="map-header-line1">You live at the continent called <span class="map-header-city" id="continentMapHeaderContinent"></span><br/><span>There are many countries here!</span></div>
        </div>
        <div id="continentMap"></div>
        <div class="map-page-number">2</div>
    </div>

    <!-- Page 5: Country Map -->
    <div class="page page-map">
        <div class="map-header">
            <div class="map-header-line1">You live at the country called <span class="map-header-city" id="countryMapHeaderCountry"></span></div>
        </div>
        <div id="countryMap"></div>
        <div class="map-page-number">3</div>
    </div>

    <!-- Page 6: City Map -->
    <div class="page page-map">
        <div class="map-header">
            <div class="map-header-line1">You live in a city called <span class="map-header-city" id="cityMapHeaderCity"></span></div>
        </div>
        <div id="cityMap"></div>
        <div class="map-page-number">4</div>
    </div>

    <!-- Page 7: Street Map -->
    <div class="page page-map">
        <div class="map-header">
            <!--div class="map-header-line1">You live in a city called <span class="map-header-city" id="mapHeaderCity"></span></div-->
            <div class="map-header-line2">Here is your address <span class="map-header-address" id="mapHeaderAddress"></span></div>
        </div>
        <div id="map"></div>
        <div class="map-page-number">5</div>
    </div>

    <!-- Page 7: Exploration Questions (Screen only) -->
    <div class="page page-explore">
        <div class="explore-title">Let's Explore Your World Together!</div>

        <div class="explore-subtitle">
            <strong>How to Use This Page (For You and Your Grown-Up)</strong><br>
            Look at the questions and explore the maps side by side. Try to find each place by reading the labels, following the streets, and comparing the different zoom levelsâ€”from the whole planet down to your street. Take turns asking and answering questions, tracing paths, and discovering new details. This activity is about exploring, talking, and learning together, so take your time and enjoy the adventure.
        </div>

        <div class="explore-section">
            <div class="explore-section-title">Planet & Continent Maps</div>
            <ol class="explore-list">
                <li>Can you find the place on the planet where you live?</li>
                <li>Can you find the mountains called the Alps?</li>
                <li>Can you find Croatia on the map?</li>
                <li>Can you find the capital of Portugal?</li>
                <li>What is the capital of your country?</li>
            </ol>
        </div>

        <div class="explore-section">
            <div class="explore-section-title">Country & City Maps</div>
            <ol class="explore-list" start="6">
                <li>Where is your city on the country map?</li>
                <li>Which province or region is it part of?</li>
                <li>Which cities or towns are nearby?</li>
            </ol>
        </div>

        <div class="explore-section">
            <div class="explore-section-title">Street & Neighborhood Map</div>
            <ol class="explore-list" start="9">
                <li>What is the name of your street?</li>
                <li>What are the street names around the one you live on?</li>
                <li>Can you find where Granny lives?</li>
                <li>Where is your school on the map?</li>
                <li>Can you spot where your family doctor is located?</li>
                <li>Where does your best friend live?</li>
                <li>Can you find your favorite playground or park?</li>
                <li>Where is the shop or supermarket your family visits often?</li>
                <li>Where do you usually take the bus or train?</li>
                <li>Can you find a place you go to for fun (sports, music, swimming)?</li>
                <li>Which street do you walk along every day?</li>
                <li>Is there a special place you like to visit with your family? Where is it on the map?</li>
            </ol>
        </div>
    </div>

    <!-- Page 8: Create Your Own Map (Screen only) -->
    <div class="page page-create">
        <div class="create-title">Let's Create Your Own Map!</div>

        <div class="create-subtitle">
            <strong>How to Use This Page (For You and Your Grown-Up)</strong> Click on the icons to place them on your map. You can mark where family members live, where you go to school, where you play, and the places you visit often. Drag the icons to move them around. As you add each icon, talk about what that place means to you and how you get there.
        </div>

        <div class="create-content">
            <div class="icons-section">
                <div class="icons-grid">
            <div class="icon-row">
                <div class="icon-item" id="icon-home-1" data-emoji="ğŸ ">ğŸ </div>
                <div class="icon-item" id="icon-home-2" data-emoji="ğŸ ">ğŸ </div>
                <div class="icon-item" id="icon-home-3" data-emoji="ğŸ ">ğŸ </div>
                <div class="icon-item" id="icon-home-4" data-emoji="ğŸ ">ğŸ </div>
                <div class="icon-item" id="icon-home-5" data-emoji="ğŸ ">ğŸ </div>
                <div class="icon-label">Home</div>
            </div>

            <div class="icon-row">
                <div class="icon-item" id="icon-granny1-1" data-emoji="ğŸ‘µğŸ»">ğŸ‘µğŸ»</div>
                <div class="icon-item" id="icon-grandpa1-1" data-emoji="ğŸ‘´ğŸ»">ğŸ‘´ğŸ»</div>
                <div class="icon-label">Granny & Grandfather</div>
            </div>

            <div class="icon-row">
                <div class="icon-item" id="icon-granny2-1" data-emoji="ğŸ‘µğŸ¼">ğŸ‘µğŸ¼</div>
                <div class="icon-item" id="icon-grandpa2-1" data-emoji="ğŸ‘´ğŸ¼">ğŸ‘´ğŸ¼</div>
                <div class="icon-label">Granny & Grandfather</div>
            </div>

            <div class="icon-row">
                <div class="icon-item" id="icon-granny3-1" data-emoji="ğŸ‘µğŸ½">ğŸ‘µğŸ½</div>
                <div class="icon-item" id="icon-grandpa3-1" data-emoji="ğŸ‘´ğŸ½">ğŸ‘´ğŸ½</div>
                <div class="icon-label">Granny & Grandfather</div>
            </div>

            <div class="icon-row">
                <div class="icon-item" id="icon-granny4-1" data-emoji="ğŸ‘µğŸ¾">ğŸ‘µğŸ¾</div>
                <div class="icon-item" id="icon-grandpa4-1" data-emoji="ğŸ‘´ğŸ¾">ğŸ‘´ğŸ¾</div>
                <div class="icon-label">Granny & Grandfather</div>
            </div>

            <div class="icon-row">
                <div class="icon-item" id="icon-granny5-1" data-emoji="ğŸ‘µğŸ¿">ğŸ‘µğŸ¿</div>
                <div class="icon-item" id="icon-grandpa5-1" data-emoji="ğŸ‘´ğŸ¿">ğŸ‘´ğŸ¿</div>
                <div class="icon-label">Granny & Grandfather</div>
            </div>

            <div class="icon-row">
                <div class="icon-item" id="icon-friend-1" data-emoji="ğŸ˜Š">ğŸ˜Š</div>
                <div class="icon-item" id="icon-friend-2" data-emoji="ğŸ˜Š">ğŸ˜Š</div>
                <div class="icon-item" id="icon-friend-3" data-emoji="ğŸ˜Š">ğŸ˜Š</div>
                <div class="icon-item" id="icon-friend-4" data-emoji="ğŸ˜Š">ğŸ˜Š</div>
                <div class="icon-item" id="icon-friend-5" data-emoji="ğŸ˜Š">ğŸ˜Š</div>
                <div class="icon-label">Best Friend</div>
            </div>

            <div class="icon-row">
                <div class="icon-item" id="icon-doctor-1" data-emoji="âš•ï¸">âš•ï¸</div>
                <div class="icon-item" id="icon-doctor-2" data-emoji="âš•ï¸">âš•ï¸</div>
                <div class="icon-item" id="icon-doctor-3" data-emoji="âš•ï¸">âš•ï¸</div>
                <div class="icon-item" id="icon-doctor-4" data-emoji="âš•ï¸">âš•ï¸</div>
                <div class="icon-item" id="icon-doctor-5" data-emoji="âš•ï¸">âš•ï¸</div>
                <div class="icon-label">Family Doctor</div>
            </div>

            <div class="icon-row">
                <div class="icon-item" id="icon-school-1" data-emoji="ğŸ«">ğŸ«</div>
                <div class="icon-item" id="icon-school-2" data-emoji="ğŸ«">ğŸ«</div>
                <div class="icon-item" id="icon-school-3" data-emoji="ğŸ«">ğŸ«</div>
                <div class="icon-item" id="icon-school-4" data-emoji="ğŸ«">ğŸ«</div>
                <div class="icon-item" id="icon-school-5" data-emoji="ğŸ«">ğŸ«</div>
                <div class="icon-label">School</div>
            </div>

            <div class="icon-row">
                <div class="icon-item" id="icon-playground-1" data-emoji="ğŸ›">ğŸ›</div>
                <div class="icon-item" id="icon-playground-2" data-emoji="ğŸ›">ğŸ›</div>
                <div class="icon-item" id="icon-playground-3" data-emoji="ğŸ›">ğŸ›</div>
                <div class="icon-item" id="icon-playground-4" data-emoji="ğŸ›">ğŸ›</div>
                <div class="icon-item" id="icon-playground-5" data-emoji="ğŸ›">ğŸ›</div>
                <div class="icon-label">Playground</div>
            </div>

            <div class="icon-row">
                <div class="icon-item" id="icon-supermarket-1" data-emoji="ğŸ›’">ğŸ›’</div>
                <div class="icon-item" id="icon-supermarket-2" data-emoji="ğŸ›’">ğŸ›’</div>
                <div class="icon-item" id="icon-supermarket-3" data-emoji="ğŸ›’">ğŸ›’</div>
                <div class="icon-item" id="icon-supermarket-4" data-emoji="ğŸ›’">ğŸ›’</div>
                <div class="icon-item" id="icon-supermarket-5" data-emoji="ğŸ›’">ğŸ›’</div>
                <div class="icon-label">Supermarket</div>
            </div>

            <div class="icon-row">
                <div class="icon-item" id="icon-bus-1" data-emoji="ğŸšŒ">ğŸšŒ</div>
                <div class="icon-item" id="icon-bus-2" data-emoji="ğŸšŒ">ğŸšŒ</div>
                <div class="icon-item" id="icon-bus-3" data-emoji="ğŸšŒ">ğŸšŒ</div>
                <div class="icon-item" id="icon-bus-4" data-emoji="ğŸšŒ">ğŸšŒ</div>
                <div class="icon-item" id="icon-bus-5" data-emoji="ğŸšŒ">ğŸšŒ</div>
                <div class="icon-label">Bus Stop</div>
            </div>

            <div class="icon-row">
                <div class="icon-item" id="icon-train-1" data-emoji="ğŸšŠ">ğŸšŠ</div>
                <div class="icon-item" id="icon-train-2" data-emoji="ğŸšŠ">ğŸšŠ</div>
                <div class="icon-item" id="icon-train-3" data-emoji="ğŸšŠ">ğŸšŠ</div>
                <div class="icon-item" id="icon-train-4" data-emoji="ğŸšŠ">ğŸšŠ</div>
                <div class="icon-item" id="icon-train-5" data-emoji="ğŸšŠ">ğŸšŠ</div>
                <div class="icon-label">Train Station</div>
            </div>

            <div class="icon-row">
                <div class="icon-item" id="icon-football-1" data-emoji="âš½">âš½</div>
                <div class="icon-item" id="icon-football-2" data-emoji="âš½">âš½</div>
                <div class="icon-item" id="icon-football-3" data-emoji="âš½">âš½</div>
                <div class="icon-item" id="icon-football-4" data-emoji="âš½">âš½</div>
                <div class="icon-item" id="icon-football-5" data-emoji="âš½">âš½</div>
                <div class="icon-label">Football</div>
            </div>

            <div class="icon-row">
                <div class="icon-item" id="icon-park-1" data-emoji="ğŸŒ³">ğŸŒ³</div>
                <div class="icon-item" id="icon-park-2" data-emoji="ğŸŒ³">ğŸŒ³</div>
                <div class="icon-item" id="icon-park-3" data-emoji="ğŸŒ³">ğŸŒ³</div>
                <div class="icon-item" id="icon-park-4" data-emoji="ğŸŒ³">ğŸŒ³</div>
                <div class="icon-item" id="icon-park-5" data-emoji="ğŸŒ³">ğŸŒ³</div>
                <div class="icon-label">Park</div>
            </div>

            <div class="icon-row">
                <div class="icon-item" id="icon-library-1" data-emoji="ğŸ“š">ğŸ“š</div>
                <div class="icon-item" id="icon-library-2" data-emoji="ğŸ“š">ğŸ“š</div>
                <div class="icon-item" id="icon-library-3" data-emoji="ğŸ“š">ğŸ“š</div>
                <div class="icon-item" id="icon-library-4" data-emoji="ğŸ“š">ğŸ“š</div>
                <div class="icon-item" id="icon-library-5" data-emoji="ğŸ“š">ğŸ“š</div>
                <div class="icon-label">Library</div>
            </div>

            <div class="icon-row">
                <div class="icon-item" id="icon-music-1" data-emoji="ğŸµ">ğŸµ</div>
                <div class="icon-item" id="icon-music-2" data-emoji="ğŸµ">ğŸµ</div>
                <div class="icon-item" id="icon-music-3" data-emoji="ğŸµ">ğŸµ</div>
                <div class="icon-item" id="icon-music-4" data-emoji="ğŸµ">ğŸµ</div>
                <div class="icon-item" id="icon-music-5" data-emoji="ğŸµ">ğŸµ</div>
                <div class="icon-label">Music Lesson</div>
            </div>

            <div class="icon-row">
                <div class="icon-item" id="icon-pool-1" data-emoji="ğŸŒŠ">ğŸŒŠ</div>
                <div class="icon-item" id="icon-pool-2" data-emoji="ğŸŒŠ">ğŸŒŠ</div>
                <div class="icon-item" id="icon-pool-3" data-emoji="ğŸŒŠ">ğŸŒŠ</div>
                <div class="icon-item" id="icon-pool-4" data-emoji="ğŸŒŠ">ğŸŒŠ</div>
                <div class="icon-item" id="icon-pool-5" data-emoji="ğŸŒŠ">ğŸŒŠ</div>
                <div class="icon-label">Swimming Pool</div>
            </div>

            <div class="icon-row">
                <div class="icon-item" id="icon-star-1" data-emoji="â­">â­</div>
                <div class="icon-item" id="icon-star-2" data-emoji="â­">â­</div>
                <div class="icon-item" id="icon-star-3" data-emoji="â­">â­</div>
                <div class="icon-item" id="icon-star-4" data-emoji="â­">â­</div>
                <div class="icon-item" id="icon-star-5" data-emoji="â­">â­</div>
                <div class="icon-label">Special Place</div>
            </div>

            <div class="icon-row">
                <div class="icon-item" id="icon-heart-1" data-emoji="â¤ï¸">â¤ï¸</div>
                <div class="icon-item" id="icon-heart-2" data-emoji="â¤ï¸">â¤ï¸</div>
                <div class="icon-item" id="icon-heart-3" data-emoji="â¤ï¸">â¤ï¸</div>
                <div class="icon-item" id="icon-heart-4" data-emoji="â¤ï¸">â¤ï¸</div>
                <div class="icon-item" id="icon-heart-5" data-emoji="â¤ï¸">â¤ï¸</div>
                <div class="icon-label">Favorite Place</div>
            </div>

            <div class="icon-row">
                <div class="icon-item" id="icon-blank-1" data-emoji="â¬œ">â¬œ</div>
                <div class="icon-item" id="icon-blank-2" data-emoji="â¬œ">â¬œ</div>
                <div class="icon-item" id="icon-blank-3" data-emoji="â¬œ">â¬œ</div>
                <div class="icon-item" id="icon-blank-4" data-emoji="â¬œ">â¬œ</div>
                <div class="icon-item" id="icon-blank-5" data-emoji="â¬œ">â¬œ</div>
                <div class="icon-label">Blank Tag</div>
            </div>

            <div class="icon-row">
                <div class="icon-item" id="icon-farm-1" data-emoji="ğŸ„">ğŸ„</div>
                <div class="icon-item" id="icon-farm-2" data-emoji="ğŸ„">ğŸ„</div>
                <div class="icon-item" id="icon-farm-3" data-emoji="ğŸ„">ğŸ„</div>
                <div class="icon-item" id="icon-farm-4" data-emoji="ğŸ„">ğŸ„</div>
                <div class="icon-item" id="icon-farm-5" data-emoji="ğŸ„">ğŸ„</div>
                <div class="icon-label">Farm</div>
            </div>

            <div class="icon-row">
                <div class="icon-item" id="icon-icecream-1" data-emoji="ğŸ¦">ğŸ¦</div>
                <div class="icon-item" id="icon-icecream-2" data-emoji="ğŸ¦">ğŸ¦</div>
                <div class="icon-item" id="icon-icecream-3" data-emoji="ğŸ¦">ğŸ¦</div>
                <div class="icon-item" id="icon-icecream-4" data-emoji="ğŸ¦">ğŸ¦</div>
                <div class="icon-item" id="icon-icecream-5" data-emoji="ğŸ¦">ğŸ¦</div>
                <div class="icon-label">Ice Cream</div>
            </div>
                </div>
            </div>

            <div class="map-section">
                <div id="interactiveMap"></div>
            </div>
        </div>
    </div>

    <!-- PDF pages as images for print only -->
    <div class="page page-map pdf-page-print-only">
        <img src="pdf_page_1.png" alt="Page 6" class="pdf-page-image">
        <div class="map-page-number">6</div>
    </div>

    <div class="page page-map pdf-page-print-only">
        <img src="pdf_page_2.png" alt="Page 7" class="pdf-page-image">
        <div class="map-page-number">7</div>
    </div>

    <script>
        // Check for admin parameter in URL
        const urlParams = new URLSearchParams(window.location.search);
        const isAdmin = urlParams.has('admin');

        // Hide admin pages if not admin
        if (!isAdmin) {
            document.addEventListener('DOMContentLoaded', function() {
                const explorePage = document.querySelector('.page-explore');
                const createPage = document.querySelector('.page-create');
                if (explorePage) explorePage.style.display = 'none';
                if (createPage) createPage.style.display = 'none';
            });
        }

        // Initialize interactive map for icon placement
        let interactiveMap = null;
        let interactiveMapGroup = null;
        let interactiveMapBehavior = null;
        let lastGeocodedPosition = null;

        // Wait for geocode to complete and initialize interactive map
        function initInteractiveMap() {
            if (interactiveMap) return; // Already initialized

            if (!lastGeocodedPosition) {
                // Use default position if no address geocoded yet
                lastGeocodedPosition = { lat: 52.5, lng: 13.4 }; // Berlin default
            }

            const platform = new H.service.Platform({
                'apikey': apiKey
            });

            const defaultLayers = platform.createDefaultLayers();
            const style = new H.map.render.harp.Style(noPoisStyleDef);
            const vectorTileService = platform.getOMVService();
            const vectorTileProvider = new H.service.omv.Provider(vectorTileService, style);
            const vectorTileLayer = new H.map.layer.TileLayer(vectorTileProvider, {
                min: 2,
                max: 22
            });

            interactiveMap = new H.Map(
                document.getElementById('interactiveMap'),
                vectorTileLayer,
                {
                    zoom: 15,
                    center: lastGeocodedPosition,
                    pixelRatio: window.devicePixelRatio || 1
                }
            );

            interactiveMapGroup = new H.map.Group();
            interactiveMap.addObject(interactiveMapGroup);

            // Enable map behavior with kinetic panning and zooming
            const mapEvents = new H.mapevents.MapEvents(interactiveMap);
            interactiveMapBehavior = new H.mapevents.Behavior(mapEvents);

            // Add default home marker at the geocoded address position
            const homeEmoji = 'ğŸ ';
            const homeIconCanvas = createEmojiIcon(homeEmoji);
            const homeMarkerElement = document.createElement('div');
            homeMarkerElement.style.cursor = 'pointer';
            homeMarkerElement.style.width = '50px';
            homeMarkerElement.style.height = '50px';
            homeMarkerElement.appendChild(homeIconCanvas);

            const homeDomIcon = new H.map.DomIcon(homeMarkerElement, {
                anchor: { x: 25, y: 45 }
            });
            const homeMarker = new H.map.DomMarker(lastGeocodedPosition, {
                icon: homeDomIcon,
                volatility: true
            });

            homeMarker.draggable = true;
            homeMarker.setData({ sourceId: 'default-home', isDefault: true });

            // Add drag event listeners
            homeMarker.addEventListener('dragstart', function(evt) {
                if (interactiveMapBehavior) {
                    interactiveMapBehavior.disable();
                }
            });

            homeMarker.addEventListener('drag', function(evt) {
                const pointer = evt.currentPointer;
                const coords = interactiveMap.screenToGeo(pointer.viewportX, pointer.viewportY);
                if (coords) {
                    homeMarker.setGeometry(coords);
                }
            });

            homeMarker.addEventListener('dragend', function(evt) {
                if (interactiveMapBehavior) {
                    interactiveMapBehavior.enable();
                }
            });

            interactiveMapGroup.addObject(homeMarker);

            window.addEventListener('resize', () => {
                interactiveMap.getViewPort().resize();
            });
        }

        // Icon placement functionality using HERE Maps DomMarker
        function createEmojiIcon(emoji) {
            // Create a canvas element for the emoji icon
            const canvas = document.createElement('canvas');
            canvas.width = 50;
            canvas.height = 50;
            const ctx = canvas.getContext('2d');

            // Draw emoji on canvas
            ctx.font = '36px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(emoji, 25, 25);

            return canvas;
        }

        document.querySelectorAll('.icon-item').forEach(icon => {
            icon.addEventListener('click', function() {
                if (this.classList.contains('used')) return;
                if (!interactiveMap) {
                    alert('Please enter an address first');
                    return;
                }

                const emoji = this.getAttribute('data-emoji');
                const iconId = this.id;

                // Create canvas icon
                const iconCanvas = createEmojiIcon(emoji);

                // Create DOM element for the marker
                const markerElement = document.createElement('div');
                markerElement.style.cursor = 'pointer';
                markerElement.style.width = '50px';
                markerElement.style.height = '50px';
                markerElement.appendChild(iconCanvas);

                // Get map center as initial position
                const center = interactiveMap.getCenter();

                // Create DomIcon from canvas with anchor point
                const domIcon = new H.map.DomIcon(markerElement, {
                    anchor: { x: 25, y: 45 }
                });

                // Create DomMarker with volatility
                const marker = new H.map.DomMarker(center, {
                    icon: domIcon,
                    volatility: true
                });

                // Make marker draggable
                marker.draggable = true;

                // Store reference to source icon
                marker.setData({ sourceId: iconId });

                // Add event listeners for drag
                marker.addEventListener('dragstart', function(evt) {
                    // Disable map behavior during marker drag
                    if (interactiveMapBehavior) {
                        interactiveMapBehavior.disable();
                    }
                });

                marker.addEventListener('drag', function(evt) {
                    // This event fires continuously while dragging
                    const pointer = evt.currentPointer;
                    const coords = interactiveMap.screenToGeo(pointer.viewportX, pointer.viewportY);
                    if (coords) {
                        marker.setGeometry(coords);
                    }
                });

                marker.addEventListener('dragend', function(evt) {
                    // Re-enable map behavior after marker drag
                    if (interactiveMapBehavior) {
                        interactiveMapBehavior.enable();
                    }
                });

                // Add marker to map
                interactiveMapGroup.addObject(marker);

                // Mark icon as used
                this.classList.add('used');
            });
        });

    </script>
    <script>
        // HERE API key
        const apiKey = 'jFKqNUf-yp9ntKrlFfHThx0vAq__yTDIHvlSA9CV6TI';
        const api_key_fta = 'zbg3dTrA4JiNKMvZS-_GYdBgMHayKZgrV65xVeRvESE';

        const mapAttrIndexEndpoint = "https://smap.hereapi.com/v8/maps/index?";
        const mapAttrEndpoint = "https://smap.hereapi.com/v8/maps/attributes?";

        // Continent bounding boxes
        const continentBBoxes = {
            "Europe": { south: 32.0, west: -12.0, north: 72.0, east: 49.0 },
            "Asia": { south: -10.0, west: 25.0, north: 81.0, east: 180.0 },
            "Africa": { south: -40.0, west: -18.0, north: 40.0, east: 54.0 },
            "North America": { south: 5.0, west: -170.0, north: 84.0, east: -10.0 },
            "South America": { south: -56.0, west: -96.0, north: 24.0, east: -30.0 },
            "Antarctica": { south: -90.0, west: -180.0, north: -60.0, east: 180.0 },
            "Australia": { south: -50.0, west: 110.0, north: 0.0, east: 180.0 }
        };

        const noPoisStyleDef = {
            "editorVersion": "1.9.0",
            "schemeVersion": "1.9.0",
            "base": { "style": "oslo", "scheme": "normal.day" },
            "definitions": {
                "POI.TransitStop.Icon.Size": 0,
                "POI.TransitAccess.Icon.Size": 0,
                "POI.MountainPeak.Icon.Size": 0,
                "POI.MountainPeak.Label.Size": [
                    "interpolate",
                    ["linear"],
                    ["zoom"],
                    5,
                    0,
                    8,
                    0,
                    12,
                    0,
                    13,
                    0,
                    15,
                    0,
                    16,
                    0,
                    20,
                    0,
                    24,
                    0
                ],
                "POI.Icon.Size": 0,
                "POI.Label.Size": [
                    "interpolate",
                    ["linear"],
                    ["zoom"],
                    5,
                    0,
                    5,
                    0,
                    8,
                    0,
                    12,
                    0,
                    13,
                    0,
                    15,
                    0,
                    16,
                    0,
                    20,
                    0,
                    24,
                    0
                ],
                "POI.TransitStop.Label.Size": [
                    "interpolate",
                    ["linear"],
                    ["zoom"],
                    5,
                    0,
                    5,
                    0,
                    8,
                    0,
                    12,
                    0,
                    13,
                    0,
                    15,
                    0,
                    16,
                    0,
                    20,
                    0,
                    24,
                    0
                ]
            }
        };

        let remainingLayersToLoad = new Array(); // if we have more than 64 tile IDs in this list then we must do multiple MapAttributes calls
        let remainingTilesToLoad  = new Array(); // if we have more than 64 tile IDs in this list then we must do multiple MapAttributes calls

        var polygonLines = {};
        var polygonLinesInn = {};

		mapAdm2Color = {
			"0": "rgba(194, 110, 139, 0.7)",
			"1": "green",
			"2": "blue",
			"8": "black",
			"9": "aqua",
		};


        // Update title name when input changes
        const nameInput = document.getElementById('nameInput');
        const titleName = document.getElementById('titleName');

        nameInput.addEventListener('input', function() {
            const name = this.value;
            titleName.textContent = name;
            // Update document title
            document.title = name ? `First Atlas for Kids - ${name}` : 'First Atlas for Kids';
        });

        // Set focus on address input on page load
        window.addEventListener('load', function() {
            addressInput.focus();
        });

        // Address autocomplete
        const addressInput = document.getElementById('addressInput');
        const autocompleteList = document.getElementById('autocompleteList');
        let debounceTimer;

        addressInput.addEventListener('input', function() {
            const query = this.value.trim();

            clearTimeout(debounceTimer);

            if (query.length < 3) {
                autocompleteList.classList.remove('show');
                return;
            }

            debounceTimer = setTimeout(() => {
                fetchAutocomplete(query);
            }, 300);
        });

        async function fetchAutocomplete(query) {
            const url = `https://autocomplete.search.hereapi.com/v1/autocomplete?q=${encodeURIComponent(query)}&apiKey=${apiKey}`;

            try {
                const response = await fetch(url);
                const data = await response.json();

                if (data.items && data.items.length > 0) {
                    showAutocomplete(data.items);
                } else {
                    autocompleteList.classList.remove('show');
                }
            } catch (error) {
                console.error('Autocomplete error:', error);
                autocompleteList.classList.remove('show');
            }
        }

        function showAutocomplete(items) {
            autocompleteList.innerHTML = '';

            items.forEach(item => {
                const div = document.createElement('div');
                div.className = 'autocomplete-item';
                div.textContent = item.title;
                div.addEventListener('click', () => {
                    addressInput.value = item.title;
                    autocompleteList.classList.remove('show');
                    // Clear previous polygons from continent and country maps
                    console.log('Clearing continent and country groups');
                    continentGroup.removeAll();
                    countryGroup.removeAll();
                    cityGroup.removeAll();
                    group.removeAll();
                    // Geocode the selected address
                    if (item.address) {
                        geocodeAddress(item.address);
                    }
                });
                autocompleteList.appendChild(div);
            });

            autocompleteList.classList.add('show');
        }

        // Geocode address to get coordinates
        async function geocodeAddress(address) {
            const params = [];

            if (address.countryCode) params.push(`country=${encodeURIComponent(address.countryCode)}`);
            if (address.state) params.push(`state=${encodeURIComponent(address.state)}`);
            if (address.city) params.push(`city=${encodeURIComponent(address.city)}`);
            if (address.postalCode) params.push(`postalCode=${encodeURIComponent(address.postalCode)}`);
            if (address.street) params.push(`street=${encodeURIComponent(address.street)}`);
            if (address.houseNumber) params.push(`houseNumber=${encodeURIComponent(address.houseNumber)}`);

            const qq = params.join(';');

            // Geocode full address
            const geocodeUrl = `https://geocode.search.hereapi.com/v1/geocode?qq=${qq}&apiKey=${apiKey}&show=tz&showMapReferences=adminIds`;

            try {
                const response = await fetch(geocodeUrl);
                const data = await response.json();

                if (data.items && data.items.length > 0) {
                    const item = data.items[0];
                    const position = item.position;
                    const geocodedAddress = item.address;
                    const timeZone = item.timeZone;
                    const mapReferences = item.mapReferences;
                    console.log('Geocoded position:', position);
                    console.log('Timezone:', timeZone);
                    console.log('Map References:', mapReferences);

                    // Save position for interactive map
                    lastGeocodedPosition = { lat: position.lat, lng: position.lng };

                    // Initialize interactive map if it hasn't been created yet
                    initInteractiveMap();

                    // Extract admin IDs from mapReferences
                    if (mapReferences) {
                        const adminIds = [];

                        // Extract ID from hmcId (format: "here:cm:namedplace:21000001")
                        const extractId = (hmcId) => {
                            if (hmcId) {
                                const parts = hmcId.split(':');
                                return parts[parts.length - 1];
                            }
                            return null;
                        };

                        // Collect IDs from different admin levels
                        if (mapReferences.country && mapReferences.country.hmcId) {
                            const id = extractId(mapReferences.country.hmcId);
                            if (id) adminIds.push(id);
                        }
                        /*if (mapReferences.state && mapReferences.state.hmcId) {
                            const id = extractId(mapReferences.state.hmcId);
                            if (id) adminIds.push(id);
                        }
                        if (mapReferences.county && mapReferences.county.hmcId) {
                            const id = extractId(mapReferences.county.hmcId);
                            if (id) adminIds.push(id);
                        }
                        if (mapReferences.city && mapReferences.city.hmcId) {
                            const id = extractId(mapReferences.city.hmcId);
                            if (id) adminIds.push(id);
                        }*/

                        console.log('Extracted admin IDs:', adminIds);

                        // Call getTileIdsByAdmId if we have IDs
                        if (adminIds.length > 0) {
                            getTileIdsByAdmId(adminIds);
                        }
                    }

                    // Update city map header
                    const city = geocodedAddress.city || geocodedAddress.county || '';
                    const street = geocodedAddress.street || '';
                    const houseNumber = geocodedAddress.houseNumber || '';
                    const streetAddress = houseNumber ? `${street} ${houseNumber}` : street;

                    //document.getElementById('mapHeaderCity').textContent = city;
                    document.getElementById('mapHeaderAddress').textContent = streetAddress;

                    // Center street map on the address
                    map.setCenter({lat: position.lat, lng: position.lng});
                    map.setZoom(17);

                    // Add markers to all maps (create separate marker instances)
                    group.removeAll();

                    const markerStreet = new H.map.Marker({lat: position.lat, lng: position.lng});
                    group.addObject(markerStreet);

                    const markerCountry = new H.map.Marker({lat: position.lat, lng: position.lng});
                    countryGroup.addObject(markerCountry);

                    const markerCity = new H.map.Marker({lat: position.lat, lng: position.lng});
                    cityGroup.addObject(markerCity);

                    // Get continent from timezone
                    const continent = timeZone && timeZone.name ? timeZone.name.split('/')[0] : '';
                    if (continent) {
                        setContinentMap(continent);
                    }

                    // Geocode country for country map
                    if (address.countryCode) {
                        geocodeCountry(address.countryCode, geocodedAddress.countryName);
                    }

                    // Geocode city for city map
                    if (address.countryCode && city) {
                        geocodeCity(address.countryCode, city);
                    }
                }
            } catch (error) {
                console.error('Geocode error:', error);
            }
        }

        // Set continent map based on timezone continent
        function setContinentMap(timezoneContinent) {
            // Map timezone continent names to our continent names
            const continentMapping = {
                "Europe": "Europe",
                "Asia": "Asia",
                "Africa": "Africa",
                "America": "North America", // Default to North America, can be refined
                "Atlantic": "Europe", // Typically Europe
                "Pacific": "Australia",
                "Indian": "Asia",
                "Antarctica": "Antarctica",
                "Australia": "Australia"
            };

            const continentName = continentMapping[timezoneContinent] || timezoneContinent;
            const bbox = continentBBoxes[continentName];

            if (bbox) {
                document.getElementById('continentMapHeaderContinent').textContent = continentName;

                const rect = new H.geo.Rect(
                    bbox.north,
                    bbox.west,
                    bbox.south,
                    bbox.east
                );
                continentMap.getViewModel().setLookAtData({bounds: rect});
            }
        }

        // Geocode country to get bounding box
        async function geocodeCountry(countryCode, countryName) {
            const geocodeUrl = `https://geocode.search.hereapi.com/v1/geocode?qq=country=${encodeURIComponent(countryCode)}&apiKey=${apiKey}&showMapReferences=adminIds`;

            try {
                const response = await fetch(geocodeUrl);
                const data = await response.json();

                if (data.items && data.items.length > 0) {
                    const item = data.items[0];
                    const mapView = item.mapView;
                    console.log('Country mapView:', mapView);

                    // Update country map header
                    document.getElementById('countryMapHeaderCountry').textContent = countryName || countryCode;

                    // Set country map to bounding box
                    if (mapView) {
                        const bbox = new H.geo.Rect(
                            mapView.north,
                            mapView.west,
                            mapView.south,
                            mapView.east
                        );
                        countryMap.getViewModel().setLookAtData({bounds: bbox});
                    }
                }
            } catch (error) {
                console.error('Country geocode error:', error);
            }
        }

        // Geocode city to get bounding box
        async function geocodeCity(countryCode, cityName) {
            const geocodeUrl = `https://geocode.search.hereapi.com/v1/geocode?qq=country=${encodeURIComponent(countryCode)};city=${encodeURIComponent(cityName)}&apiKey=${apiKey}&showMapReferences=adminIds`;

            try {
                const response = await fetch(geocodeUrl);
                const data = await response.json();

                if (data.items && data.items.length > 0) {
                    const item = data.items[0];
                    const mapView = item.mapView;
                    console.log('City mapView:', mapView);

                    // Update city map header
                    document.getElementById('cityMapHeaderCity').textContent = cityName;

                    // Set city map to bounding box
                    if (mapView) {
                        const bbox = new H.geo.Rect(
                            mapView.north,
                            mapView.west,
                            mapView.south,
                            mapView.east
                        );
                        cityMap.getViewModel().setLookAtData({bounds: bbox});
                    }
                }
            } catch (error) {
                console.error('City geocode error:', error);
            }
        }

        // Hide autocomplete on click outside
        document.addEventListener('click', function(e) {
            if (!addressInput.contains(e.target) && !autocompleteList.contains(e.target)) {
                autocompleteList.classList.remove('show');
            }
        });

        // Continent map (Page 3)
        const continentPlatform = new H.service.Platform({
            'apikey': apiKey
        });
        const continentDefaultLayers = continentPlatform.createDefaultLayers();
        const continentStyle = new H.map.render.harp.Style("onlyfc1-2-noshields.tar.gz");
        const continentVectorTileService = continentPlatform.getOMVService();
        const continentVectorTileProvider = new H.service.omv.Provider(continentVectorTileService, continentStyle);
        const continentVectorTileLayer = new H.map.layer.TileLayer(continentVectorTileProvider);

        const continentMap = new H.Map(
            document.getElementById('continentMap'),
            continentVectorTileLayer,
            {
                zoom: 3,
                pixelRatio: window.devicePixelRatio || 1
            }
        );
        const continentGroup = new H.map.Group();
        continentMap.addObject(continentGroup);
        const continentBehavior = new H.mapevents.Behavior(new H.mapevents.MapEvents(continentMap));

        const continentUI = H.ui.UI.createDefault(continentMap, continentDefaultLayers);
        continentUI.removeControl("mapsettings");
        continentUI.removeControl("zoom");

        // Country map (Page 4)
        const countryPlatform = new H.service.Platform({
            'apikey': apiKey
        });
        const countryDefaultLayers = countryPlatform.createDefaultLayers();
        const countryStyle = new H.map.render.harp.Style("onlyfc1-2-noshields.tar.gz");
        const countryVectorTileService = countryPlatform.getOMVService();
        const countryVectorTileProvider = new H.service.omv.Provider(countryVectorTileService, countryStyle);
        const countryVectorTileLayer = new H.map.layer.TileLayer(countryVectorTileProvider);

        const countryMap = new H.Map(
            document.getElementById('countryMap'),
            countryVectorTileLayer,
            {
                zoom: 3,
                pixelRatio: window.devicePixelRatio || 1
            }
        );
        const countryGroup = new H.map.Group();
        countryMap.addObject(countryGroup);
        const countryBehavior = new H.mapevents.Behavior(new H.mapevents.MapEvents(countryMap));

        const countryUI = H.ui.UI.createDefault(countryMap, countryDefaultLayers);
        countryUI.removeControl("mapsettings");
        countryUI.removeControl("zoom");

        // City map (Page 5)
        const cityPlatform = new H.service.Platform({
            'apikey': apiKey
        });
        const cityDefaultLayers = cityPlatform.createDefaultLayers();
        const cityStyle = new H.map.render.harp.Style(noPoisStyleDef);
        const cityVectorTileService = cityPlatform.getOMVService();
        const cityVectorTileProvider = new H.service.omv.Provider(cityVectorTileService, cityStyle);
        const cityVectorTileLayer = new H.map.layer.TileLayer(cityVectorTileProvider);

        const cityMap = new H.Map(
            document.getElementById('cityMap'),
            cityVectorTileLayer,
            {
                zoom: 3,
                pixelRatio: window.devicePixelRatio || 1
            }
        );
        const cityGroup = new H.map.Group();
        cityMap.addObject(cityGroup);
        const cityBehavior = new H.mapevents.Behavior(new H.mapevents.MapEvents(cityMap));

        const cityUI = H.ui.UI.createDefault(cityMap, cityDefaultLayers);
        cityUI.removeControl("mapsettings");
        cityUI.removeControl("zoom");

        // Street map (Page 6)
        const streetPlatform = new H.service.Platform({
            'apikey': apiKey
        });
        const streetDefaultLayers = streetPlatform.createDefaultLayers();
        const streetStyle = new H.map.render.harp.Style(noPoisStyleDef);
        const streetVectorTileService = streetPlatform.getOMVService();
        const streetVectorTileProvider = new H.service.omv.Provider(streetVectorTileService, streetStyle);
        const streetVectorTileLayer = new H.map.layer.TileLayer(streetVectorTileProvider);

        const map = new H.Map(
            document.getElementById('map'),
            streetVectorTileLayer,
            {
                zoom: 3,
                pixelRatio: window.devicePixelRatio || 1
            }
        );

        const group = new H.map.Group();
        map.addObject(group);

        const streetUI = H.ui.UI.createDefault(map, streetDefaultLayers);
        streetUI.removeControl("mapsettings");
        streetUI.removeControl("zoom");

        window.addEventListener('resize', () => {
            map.getViewPort().resize();
            cityMap.getViewPort().resize();
            countryMap.getViewPort().resize();
            continentMap.getViewPort().resize();
        });

        const behavior = new H.mapevents.Behavior(new H.mapevents.MapEvents(map));



        function getTileIdsByAdmId(admIds) {
            polygonLines = {};
            polygonLinesInn = {};

            function onResponce() {
                let tiles = JSON.parse(this.responseText);
                //console.log("getTileIdsByAdmId tiles:", tiles);
                /*let admTileIds = {
                    tileIds:
                    admins.geometries.map(x => x.attributes.ADMIN_PLACE_ID)
                };*/
                let lrsTls = tiles.Layers.reduce(
                    (prevV, currV) => {
                        let arrTs = prevV.tileIds.concat(currV.tileIDs);
                        let layers = Array(currV.tileIDs.length);
                        let arrLrStr = currV.layer.split("_");
                        layers.fill("ADMIN_POLY_" + arrLrStr[arrLrStr.length - 1]);
                        layers = prevV.layers.concat(layers);
                        //console.log("arrTs, layers:", arrTs, layers);
                        return {
                            tileIds: arrTs,
                            layers: layers
                        };
                    },
                    {
                        tileIds: [],
                        layers: []
                    }
                );
                console.log("admIds:", admIds, lrsTls);
                remainingLayersToLoad = lrsTls.layers;
                remainingTilesToLoad  = lrsTls.tileIds;
                getPolyAdminByTileIds(admIds);
            }
            const req = new XMLHttpRequest();
            req.addEventListener("load", onResponce);
            req.open("GET", `${mapAttrIndexEndpoint}layer=ADMIN_PLACE_n&attributes=ADMIN_PLACE_ID&values=${admIds.join(",")}&apikey=${api_key_fta}`);
            req.send();		
        }

        
        function getPolyAdminByTileIds(admIds){
            //console.log("getPolyAdminByTileIds admIds:", admIds);
            function onResponce() {
                let admPolys = JSON.parse(this.responseText);
                //console.log("adm polys:", admPolys);
                /*if(admIds.length == 1){
                    admPolys = admPolys.filter(it => it);
                }*/
                parse2Polylines(admPolys, admIds);
                getPolyAdminByTileIds(admIds); // continue to request the remaining tiles
            }
            if (remainingLayersToLoad.length == 0) {
                //console.log("mapAdmins:", mapAdmins);
                /*let sumRect;
                //let allGeoms = new H.map.Group();
                Object.keys(mapAdmins).forEach(function (key) {
                    let grpBb = mapAdmins[key].provider.getRootGroup().getBoundingBox();
                    if(!sumRect && grpBb){
                        sumRect = grpBb.clone();
                    }
                    if(grpBb){
                        H.geo.Rect.merge(sumRect.getTop(), sumRect.getLeft(), sumRect.getBottom(), sumRect.getRight(),
                            grpBb.getTop(), grpBb.getLeft(), grpBb.getBottom(), grpBb.getRight(), sumRect);
                    }
                    //console.log("sumRect:", sumRect);
                    
                    
                });*/
                //console.log("setLookAtData:", sumRect);
                //map.getViewModel().setLookAtData({bounds: sumRect}, true);
                return;
            };
            let layersToLoad  = new Array(); for (var i = 0; i < 64 && remainingLayersToLoad.length > 0; i++) layersToLoad .push(remainingLayersToLoad.shift());
            let tileIdsToLoad = new Array(); for (var i = 0; i < 64 && remainingTilesToLoad .length > 0; i++) tileIdsToLoad.push(remainingTilesToLoad.shift());
            const layers = encodeURIComponent(layersToLoad.join(","));
            const inTiles = "tile:" + tileIdsToLoad.join(",");
            //const filter = admIds.length == 1 ? "&filter=" + encodeURIComponent("ADMIN_PLACE_ID=" + admIds[0]) : ""; <- doesn't work!!! for in=tiles?
            const filter = "";
            const req = new XMLHttpRequest();
            req.addEventListener("load", onResponce);
            req.open("GET", `${mapAttrEndpoint}layers=${layers}&in=${inTiles}${filter}&apikey=${api_key_fta}`);
            req.send();		

        }


        function parse2Polylines(r, admIds){
            var adminId2Data = {};
            var rowLats = [];
            var rowLngs = [];
            var rowLatsLngsInn = {"LAT": "", "LON": ""};
            var adminLevel;
            for(let i=0,len=r.Tiles.length; i<len; i++){
                let
                    tile = r.Tiles[i],
                    tId = tile.Meta.tileId,
                    rows = tile.Rows,
                    arrLrStr = tile.Meta.layerName.split("_");
                adminLevel = arrLrStr[arrLrStr.length - 1];

                for(let i=0,len=rows.length; i<len; i++){
                    if(!admIds.includes(rows[i].ADMIN_PLACE_ID)){
                        continue;
                    }
                    let admId = rows[i].ADMIN_PLACE_ID;
                    adminId2Data[admId] = adminId2Data[admId] || {};
                    polygonLines[admId] = polygonLines[admId] || [];
                    rowLats.push(rows[i].LAT);
                    rowLngs.push(rows[i].LON);

                    let
                        row = rows[i],
                        {SOURCE_TYPE, ADMIN_ORDER, ADMIN_PLACE_ID, FEATURE_TYPE, NAME} = row
                        data = {NAME, ADMIN_ORDER, ADMIN_PLACE_ID, FEATURE_TYPE, SOURCE_TYPE},
                        sLat = row.LAT.split(","),
                        sLng = row.LON.split(","),
                        sLatInn = row.INNER_LAT ? row.INNER_LAT.split(",") : [],
                        sLngInn = row.INNER_LON ? row.INNER_LON.split(",") : [],
                        lats = sLat.map(x => (x == "" ? 0 : parseInt(x))),
                        lngs = sLng.map(x => (x == "" ? 0 : parseInt(x))),
                        latsInn = sLatInn.map(x => (x == "" ? 0 : parseInt(x))),
                        lngsInn = sLngInn.map(x => (x == "" ? 0 : parseInt(x))),
                        prevLat = 0, prevLng = 0,
                        prevLatInn = 0, prevLngInn = 0,
                        polygonStrip = new H.geo.LineString(),
                        polygonStripInn = new H.geo.LineString(),
                        coords = new Array(),
                        coordsInn = new Array(),
                        alllines = new Array(),
                        alllinesInn = new Array();
                    adminId2Data[admId].borderColor = mapAdm2Color[adminLevel];
                    adminId2Data[admId].data = data;
                    for(let i=0,len=lats.length; i<len; i++){
                        lats[i] = prevLat + lats[i];
                        lngs[i] = prevLng + lngs[i];
                        prevLat = lats[i], prevLng = lngs[i];
                        lats[i] = lats[i] / 100000;
                        lngs[i] = lngs[i] / 100000;
                        polygonStrip.pushPoint(new H.geo.Point(lats[i], lngs[i]));
                    }
                    for(let i=0,len=latsInn.length; i<len; i++){
                        latsInn[i] = prevLatInn + latsInn[i];
                        lngsInn[i] = prevLngInn + lngsInn[i];
                        prevLatInn = latsInn[i], prevLngInn = lngsInn[i];
                        latsInn[i] = latsInn[i] / 100000;
                        lngsInn[i] = lngsInn[i] / 100000;
                        polygonStripInn.pushPoint(new H.geo.Point(latsInn[i], lngsInn[i]));
                    }
                    let lineString = new H.geo.LineString();
                    for(let i=0,len=lats.length; i<len; i++){
                        let g = sLng[i].toString();
                        if(g.charAt(0) === '-')
                            g = g.substr(1);
                        if(g.indexOf("0") === 0 && sLng[i] != 0 || g == "00") { // next line is artifical
                            if(i == 0) { // start of array
                                continue;
                            }
                            lineString.pushPoint({lat: lats[i], lng: lngs[i]});
                            coords.push(new H.geo.Point(lats[i], lngs[i]));
                            alllines.push(coords);
                            lineString = new H.geo.LineString();
                            coords = new Array();
                            continue;
                        }
                        lineString.pushPoint({lat: lats[i], lng: lngs[i]});
                        coords.push(new H.geo.Point(lats[i], lngs[i]));
                    }
                    let lineStringInn = new H.geo.LineString();
                    for(let i=0,len=latsInn.length; i<len; i++){
                        let g = sLngInn[i].toString();
                        if(g.charAt(0) === '-')
                            g = g.substr(1);
                        if(g.indexOf("0") === 0 && sLngInn[i] != 0 || g == "00") { // next line is artifical
                            if(i == 0) { // start of array
                                continue;
                            }
                            lineStringInn.pushPoint({lat: latsInn[i], lng: lngsInn[i]});
                            coordsInn.push(new H.geo.Point(latsInn[i], lngsInn[i]));
                            alllinesInn.push(coordsInn);
                            lineStringInn = new H.geo.LineString();
                            coordsInn = new Array();
                            continue;
                        }
                        lineStringInn.pushPoint({lat: latsInn[i], lng: lngsInn[i]});
                        coordsInn.push(new H.geo.Point(latsInn[i], lngsInn[i]));
                    }
                    alllines.push(coords);
                    alllinesInn.push(coordsInn);
                    alllines.forEach(crds => {
                        if (crds && crds.length > 1){
                            polygonLines[admId].push( crds.map(p => [p.lat, p.lng]) );
                        }
                    });
                    if(alllinesInn[0].length != 0){
                        polygonLinesInn[admId] = polygonLinesInn[admId] || [];
                    }
                    alllinesInn.forEach(crds => {
                        if (crds && crds.length > 1){
                            polygonLinesInn[admId].push( crds.map(p => [p.lat, p.lng]) );
                        }
                    });
                }
            }

            // polylinesDictToHereLineStrings in the module lines2polygons
            const polygs = polylinesDictToHereLineStrings(polygonLines, {decimals: 5, allowUnclosed: false});
            const polygsInn = polylinesDictToHereLineStrings(polygonLinesInn, {decimals: 5, allowUnclosed: false});
            for (const [admId, v] of Object.entries(polygs)) {
                v.forEach((it, idx) => {
                    let seqPointsPoly = [];
                    let ls = new H.geo.LineString();
                    it.forEach(pl => {
                        ls.pushLatLngAlt(pl[0], pl[1]);
                        seqPointsPoly.push({y: pl[0], x: pl[1]});
                    });
                    let arrLinesInn = [];
                    for (const [kInn, vInn] of Object.entries(polygsInn)) {
                        vInn.forEach((itInn, idx) => {
                            let p = {y: itInn[0][0], x: itInn[0][1]};
                            // isPointInPolygon in the module pointInPolygon
                            if(isPointInPolygon(p, seqPointsPoly)){
                                let lsInn = new H.geo.LineString();
                                itInn.forEach(pl => {
                                    lsInn.pushLatLngAlt(pl[0], pl[1]);
                                });
                                arrLinesInn.push(lsInn);
                            }
                        });
                    }
                    var randomColor = 0;
                    for (var cc = 0; cc < admId.length; cc++)
                        randomColor += admId.charCodeAt(cc) * 137 + 19;
                    const geoPolyg = new H.geo.Polygon(ls, arrLinesInn);

                    const polygonStyleContinent = {
                        //fillColor: 'rgba(' + randomColor % 256 + ',' + (randomColor * 7 + 3) % 256 + ',' + (randomColor * 13 + 5) % 256 + ', 0.2)',
                        fillColor: adminId2Data[admId].borderColor,
                        lineWidth: 4,
                        strokeColor: adminId2Data[admId].borderColor
                    };

                    const polygonStyleCountry = {
                        fillColor: 'rgba(0, 0, 0, 0)', // completely transparent
                        lineWidth: 4,
                        strokeColor: adminId2Data[admId].borderColor
                    };

                    // Create two separate polygon instances for different maps
                    var polygonContinent = new H.map.Polygon(geoPolyg, { style: polygonStyleContinent });
                    polygonContinent.setData(adminId2Data[admId].data);

                    var polygonCountry = new H.map.Polygon(geoPolyg, { style: polygonStyleCountry });
                    polygonCountry.setData(adminId2Data[admId].data);

                    //console.log('Adding polygon to maps:', admId, adminId2Data[admId]);
                    continentGroup.addObject(polygonContinent);
                    countryGroup.addObject(polygonCountry);
                });
                
            }
            rowLatsLngsInn.LAT = rowLats;
            rowLatsLngsInn.LON = rowLngs;
        }

        //functions for concat polylines to polygon
        /**
         * Input:
         * linesById = {
         *   1: [[lat,lng],[lat,lng], ...],          // single polyline for id=1
         *   2: [ [[lat,lng],...], [[lat,lng],...] ],// (optional) multiple polylines for an id
         *   3: [[lat,lng],[lat,lng], ...],
         *   ...
         * }
         * options: {
         *   decimals?: number,          // snap precision for matching polyline endpoints (default 5)
         *                                // Applied ONLY to start/end points, NOT to intermediate points
         *   allowUnclosed?: boolean     // allow unclosed rings in output (default true)
         *                                // If false, only naturally closed rings will be returned
         * }
         *
         * Output:
         * { [polygon_id]: H.geo.LineString[] }  // one closed ring per LineString (no holes)
         */
            function polylinesDictToHereLineStrings(linesById, options = {}) {
            const decimals = options.decimals ?? 5;
            const allowUnclosed = options.allowUnclosed ?? true;
            console.log("decimals:", decimals);
            console.log("allowUnclosed:", allowUnclosed);

            const keyOf = (p) => `${Number(p[0]).toFixed(decimals)},${Number(p[1]).toFixed(decimals)}`;

            // Calculate distance between two points in meters (flat projection, no Earth curvature)
            const distanceFlat = (p1, p2) => {
                const lat = (p1[0] + p2[0]) / 2; // average latitude for lng scaling
                const latDiff = p1[0] - p2[0];
                const lngDiff = p1[1] - p2[1];

                const metersPerDegreeLat = 111000; // approximately 111 km per degree latitude
                const metersPerDegreeLng = 111000 * Math.cos(lat * Math.PI / 180);

                const latDist = latDiff * metersPerDegreeLat;
                const lngDist = lngDiff * metersPerDegreeLng;

                return Math.sqrt(latDist * latDist + lngDist * lngDist);
            };

            // Build rings from a list of polylines (array of coord arrays)
            const ringsFromGroup = (coordsList) => {
                const startMap = new Map(); // pointKey -> polylines starting here
                const endMap   = new Map(); // pointKey -> polylines ending here
                const segments = [];        // { a, b, pts: entire polyline, used:false }

                const pushTo = (m, k, v) => { const arr = m.get(k); arr ? arr.push(v) : m.set(k, [v]); };

                // Treat each polyline as a single segment
                for (const coords of coordsList) {
                if (coords.length < 2) continue; // skip empty polylines
                const a = coords[0];                    // first point (decimals applied here)
                const b = coords[coords.length - 1];    // last point (decimals applied here)
                const seg = { a, b, pts: coords, used: false };  // store entire polyline
                segments.push(seg);
                pushTo(startMap, keyOf(a), seg);
                pushTo(endMap,   keyOf(b), seg);
                }

                const takeNext = (endKey) => {
                const s = startMap.get(endKey);
                if (s) for (const seg of s) if (!seg.used) return { seg, reverse: false };
                const e = endMap.get(endKey);
                if (e) for (const seg of e) if (!seg.used) return { seg, reverse: true };
                return null;
                };

                // Find nearest unused segment within maxDistance (in meters)
                const findNearestUnused = (fromPt, maxDistance) => {
                let nearest = null;
                let minDist = maxDistance;

                for (const seg of segments) {
                    if (seg.used) continue;

                    // Check distance to segment start
                    const distToStart = distanceFlat(fromPt, seg.a);
                    if (distToStart < minDist) {
                    minDist = distToStart;
                    nearest = { seg, reverse: false, distance: distToStart, connectTo: seg.a };
                    }

                    // Check distance to segment end
                    const distToEnd = distanceFlat(fromPt, seg.b);
                    if (distToEnd < minDist) {
                    minDist = distToEnd;
                    nearest = { seg, reverse: true, distance: distToEnd, connectTo: seg.b };
                    }
                }

                return nearest;
                };

                const unused = () => segments.find(s => !s.used);
                const rings = [];

                while (true) {
                const first = unused();
                if (!first) break;

                first.used = true;
                let ring = [...first.pts];
                const startKey = keyOf(ring[0]);
                let endKey = keyOf(ring[ring.length - 1]);
                let naturallyClosed = false;

                while (true) {
                    const pick = takeNext(endKey);

                    if (!pick) {
                    // No exact match found
                    const currentEnd = ring[ring.length - 1];

                    // First, check if we can close the ring by bridging to its start point
                    const distanceToStart = distanceFlat(currentEnd, ring[0]);
                    if (distanceToStart <= 500) {
                        //console.log(`  Bridging gap to close ring: ${distanceToStart.toFixed(2)}m from [${currentEnd[0].toFixed(6)}, ${currentEnd[1].toFixed(6)}] to [${ring[0][0].toFixed(6)}, ${ring[0][1].toFixed(6)}]`);
                        naturallyClosed = true;
                        break; // ring closed via gap bridging
                    }

                    // Otherwise, try to find nearest unused segment within 500m
                    const nearest = findNearestUnused(currentEnd, 500);

                    if (nearest) {
                        console.log(`  Bridging gap: ${nearest.distance.toFixed(2)}m from [${currentEnd[0].toFixed(6)}, ${currentEnd[1].toFixed(6)}] to [${nearest.connectTo[0].toFixed(6)}, ${nearest.connectTo[1].toFixed(6)}]`);

                        // Add connecting point
                        ring.push(nearest.connectTo);

                        // Mark segment as used and add its points
                        nearest.seg.used = true;
                        const pts = nearest.reverse ? [...nearest.seg.pts].reverse() : nearest.seg.pts;
                        ring.push(...pts.slice(1)); // skip first point (it's the connection point)

                        endKey = keyOf(ring[ring.length - 1]);
                        if (endKey === startKey) {
                        naturallyClosed = true;
                        break; // closed
                        }
                        continue;
                    }

                    break;
                    }

                    pick.seg.used = true;
                    const pts = pick.reverse ? [...pick.seg.pts].reverse() : pick.seg.pts;

                    // append all points (no deduplication to preserve precision)
                    ring.push(...pts.slice(1));  // skip first point (it's the connection point)

                    endKey = keyOf(ring[ring.length - 1]);
                    if (endKey === startKey) {
                    naturallyClosed = true;
                    break; // closed
                    }
                }

                // ensure closed ring by adding first point at the end
                ring.push(ring[0]);

                // Add ring to results if it meets criteria
                if (ring.length >= 4) {
                    if (allowUnclosed || naturallyClosed) {
                    rings.push(ring);
                    } else {
                    console.log(`  Skipping unclosed ring with ${ring.length} points`);
                    }
                }
                }

                return rings; // array of closed [lat,lng] rings
            };

            // Convert rings -> H.geo.LineString[]
            const out = {};
            for (const id of Object.keys(linesById)) {
                const val = linesById[id];

                // normalize: allow either a single polyline or an array of polylines
                const coordsList = Array.isArray(val[0][0])
                ? val                                   // already array of polylines
                : [val];                                // single polyline -> wrap

                const rings = ringsFromGroup(coordsList);
                if (!rings.length) continue;

                out[id] = rings;
                /*out[id] = rings.map(r => {
                const ls = new H.geo.LineString();
                for (const [lat, lng] of r) ls.pushLatLngAlt(lat, lng); // altitude optional
                return ls;
                });*/
            }
            return out;
        }

        // ==== example ====
        /*const lines = {
        1: [[52.0,13.0],[52.0,14.0],[53.0,14.0],[53.0,13.0],[52.0,13.0]], // already a closed ring (ok)
        2: [[50.0,8.0],[50.0,9.0],[51.0,9.0],[51.0,8.0],[50.0,8.0]],      // single polyline
        3: [                                                             // multiple polylines for the same id
            [[48.0,11.0],[48.0,12.0],[49.0,12.0]],
            [[49.0,12.0],[49.0,11.0],[48.0,11.0]]
        ]
        };

        const res = polylinesDictToHereLineStrings(lines, { decimals: 6 });
        // Ñ‚ĞµĞ¿ĞµÑ€ÑŒ res = { "1": [H.geo.LineString], "2": [H.geo.LineString], "3": [H.geo.LineString] }

        // Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ñ Ğ½Ğ° ĞºĞ°Ñ€Ñ‚Ñƒ:
        Object.entries(res).forEach(([id, lineStrings]) => {
        lineStrings.forEach(ls => {
            const polygon = new H.map.Polygon(ls);
            polygon.setData({ polygon_id: id });
            map.addObject(polygon);
        });
        });*/
        //--------------end concat polylines to polygon

        function isPointInPolygon(testPoint, polygPoints) {
            let result = false;
            let j = polygPoints.length - 1;
            for(let i=0, len=j+1; i<len; i++){
                let p = polygPoints[i];
                let lP = polygPoints[j];
                if(p.y < testPoint.y && lP.y >= testPoint.y || lP.y < testPoint.y && p.y >= testPoint.y){
                    if((p.x + (testPoint.y - p.y) / (lP.y - p.y) * (lP.x - p.x)) < testPoint.x){
                        result = !result;
                    }
                }
                j = i;
            }
            return result;
        }

    </script>
</body>
</html>
